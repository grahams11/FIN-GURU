ts// src/main.ts  (Replit: create src folder + main.ts)
import 'dotenv/config';
import WebSocket from 'ws';
import axios from 'axios';
import TelegramBot from 'node-telegram-bot-api';

// ==================== CONFIG ====================
const POLYGON_KEY = process.env.POLYGON_KEY!;
const TASTY_TOKEN = process.env.TASTY_TOKEN!;
const TELEGRAM_TOKEN = process.env.TELEGRAM_BOT_TOKEN!;
const TELEGRAM_CHAT_ID = parseInt(process.env.TELEGRAM_CHAT_ID!);

if (!POLYGON_KEY || !TASTY_TOKEN || !TELEGRAM_TOKEN || !TELEGRAM_CHAT_ID) {
  console.error("Add POLYGON_KEY, TASTY_TOKEN, TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID to Secrets!");
  process.exit(1);
}

const bot = new TelegramBot(TELEGRAM_TOKEN);
const TASTY_HEADERS = { headers: { Authorization: `Bearer ${TASTY_TOKEN}` }};

// High-volume weeklies only
const TICKERS = ['NVDA','TSLA','SPY','QQQ','AMD','META','AAPL','AMZN','GOOGL','MSFT','SMCI','COIN','MARA','HOOD','RIVN'];

// ==================== STATE ====================
interface Sweep { ticker: string; premium: number; side: 'C'|'P'; time: number; }
const recentSweeps: Sweep[] = [];

// ==================== HELPERS ====================
async function getPrice(ticker: string) {
  const res = await axios.get(`https://api.polygon.io/v2/last/trade/${ticker}?apiKey=${POLYGON_KEY}`);
  return res.data.last?.price || 0;
}

async function getMaxPain(ticker: string, expiry: string) {
  const res = await axios.get(`https://api.polygon.io/v3/reference/options/contracts`, {
    params: { underlying_ticker: ticker, expiration_date: expiry, limit: 1000, apiKey: POLYGON_KEY }
  });
  const oi: Record<number, number> = {};
  for (const c of res.data.results) {
    oi[c.strike_price] = (oi[c.strike_price] || 0) + (c.open_interest || 0);
  }
  return Object.entries(oi).sort((a,b) => b[1]-a[1])[0]?.[0] || null;
}

async function getIVSkew(ticker: string) {
  try {
    const res = await axios.get(`https://api.tastytrade.com/option-chains/${ticker}/nested`, TASTY_HEADERS);
    const calls = res.data.items.filter((i: any) => i['option-type'] === 'CALL');
    const puts = res.data.items.filter((i: any) => i['option-type'] === 'PUT');
    const cIV = calls.reduce((s: number, c: any) => s + (c['implied-volatility']||0), 0) / calls.length;
    const pIV = puts.reduce((s: number, c: any) => s + (c['implied-volatility']||0), 0) / puts.length;
    return { callIV: cIV, putIV: pIV };
  } catch { return null; }
}

async function getRSI(ticker: string) {
  const res = await axios.get(`https://api.polygon.io/v2/aggs/ticker/${ticker}/range/1/day/prev/20?apiKey=${POLYGON_KEY}`);
  const closes = res.data.results.map((r: any) => r.c);
  let gains = 0, losses = 0;
  for (let i = 1; i < closes.length; i++) {
    const diff = closes[i] - closes[i-1];
    if (diff > 0) gains += diff; else losses += -diff;
  }
  const avgGain = gains / 14, avgLoss = losses / 14 || 1;
  return 100 - (100 / (1 + avgGain/avgLoss));
}

// ==================== WEBSOCKET – GHOST SWEEPS ====================
const ws = new WebSocket('wss://socket.polygon.io/options');

ws.on('open', () => {
  console.log('Polygon WS Connected');
  ws.send(JSON.stringify({ action: 'auth', params: POLYGON_KEY }));
  ws.send(JSON.stringify({ action: 'subscribe', params: TICKERS.map(t => `T.${t}.*`).join(',') }));
});

ws.on('message', (data: string) => {
  const msgs = JSON.parse(data.toString());
  for (const m of msgs) {
    if (m.ev !== 'T') continue;
    const size = m.s || 0;
    const price = m.p || 0;
    const premium = size * price * 100;
    const cond = m.c || [];
    const isSweep = cond.includes(10) || cond.includes(11) || cond.includes(12) || cond.includes(13);
    if (premium > 2_000_000 && isSweep) {
      const ticker = m.sym.split('.')[0];
      const side = m.sym.includes('C') ? 'C' : 'P';
      recentSweeps.push({ ticker, premium, side, time: Date.now() });
      console.log(`GHOST SWEEP: ${ticker} ${side} $${premium.toLocaleString()}`);
    }
  }
});

// ==================== SCANNER ====================
async function scan() {
  console.log(`[${new Date().toLocaleTimeString()}] Scanning for NVDA-style ghosts...`);
  const candidates: any[] = [];

  for (const t of TICKERS) {
    try {
      const price = await getPrice(t);
      if (!price) continue;

      // Next Friday expiry
      const today = new Date();
      const friday = new Date(today);
      friday.setDate(today.getDate() + ((5 - today.getDay() + 7) % 7 || 7));
      const expiry = friday.toISOString().split('T')[0];

      const maxPain = await getMaxPain(t, expiry);
      if (!maxPain) continue;
      const proximity = Math.abs(price - maxPain) / price;
      const gammaTrap = proximity < 0.009; // ±0.9%

      const skew = await getIVSkew(t);
      if (!skew) continue;
      const bullishSkew = skew.callIV < skew.putIV * 0.90;

      const sweeps = recentSweeps.filter(s => s.ticker === t && Date.now() - s.time < 30*60*1000 && s.premium > 2_000_000);
      const bigSweep = sweeps.length > 0;

      const rsi = await getRSI(t);
      const rsiExtreme = rsi < 32 || rsi > 68;

      const score = (gammaTrap ? 30 : 0) + (bullishSkew ? 25 : 0) + (bigSweep ? 30 : 0) + (rsiExtreme ? 15 : 0);
      if (score >= 94) {
        candidates.push({
          ticker: t,
          score,
          direction: bullishSkew ? 'CALL' : 'PUT',
          strike: maxPain,
          expiry,
          sweeps: sweeps.length,
          premiumTotal: sweeps.reduce((a,s)=>a+s.premium,0),
          roi: `${380 + (score-94)*60}% - ${800 + (score-94)*100}%`
        });
      }
    } catch (e) { console.error(t, e); }
  }

  candidates.sort((a,b) => b.score - a.score);
  for (const c of candidates.slice(0,2)) {
    const msg = `
GHOST FOUND – NVDA REPLAY
${c.ticker} ${c.direction} ${c.expiry.replace(/-/g,'').slice(2)} $${c.strike}
Score: ${c.score}/100 | ROI: ${c.roi}
Sweeps: ${c.sweeps} ($${c.premiumTotal.toLocaleString()})
Max Pain Pin: ±0.9% | RSI Extreme
EXECUTE 9:30 AM TOMORROW
    `.trim();
    await bot.sendMessage(TELEGRAM_CHAT_ID, msg);
    console.log("GHOST ALERT SENT:", c.ticker);
  }
}

// ==================== RUN ====================
console.log("GHOST SCANNER v6.0 LIVE – Hunting NVDA clones");
setInterval(() => {
  const estHour = new Date().toLocaleString('en-US', { timeZone: 'America/New_York', hour: '2-digit', hour12: false });
  if (parseInt(estHour) >= 14) scan();
}, 60000); // Every minute after 2 PM EST
package.json
json{
  "name": "ghost-scanner-v6",
  "version": "6.0.0",
  "main": "dist/main.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/main.js"
  },
  "dependencies": {
    "axios": "^1.7.7",
    "dotenv": "^16.4.5",
    "node-telegram-bot-api": "^0.66.0",
    "ws": "^8.18.0"
  },
  "devDependencies": {
    "typescript": "^5.6.2",
    "@types/node": "^22.7.4",
    "@types/ws": "^8.5.12"
  }
}
tsconfig.json
json{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true
  }
}
.env (Replit Secrets)
envPOLYGON_KEY=your_polygon_key
TASTY_TOKEN=your_tasty_session_token
TELEGRAM_BOT_TOKEN=123456:ABCDEF
TELEGRAM_CHAT_ID=123456789
REPLIT SETUP (3 MINUTES)

New Replit → Node.js
Create src/main.ts → paste code
Paste package.json, tsconfig.json
Shell:

bashnpm install
npx tsc --init
npm run build
npm start

Secrets → add .env values
Run → It will catch every NVDA-style ghost from now on.